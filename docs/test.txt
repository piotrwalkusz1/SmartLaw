definition Asset

definition AssetDelegator<T: Asset, R: Collection> {
	count: uint;
	delegatedTo: Id<R>;
}

function Delegate<T: Asset, R: Collection<AssetDelegator<T, R>>>(delegateFrom: Id<R>, delegateTo: Id<R>) {
    while (R[delegateTo].delegateTo != null) {
        delegateTo = R[delegateTo].delegateTo;
        require(delegateTo != delegateFrom);
    }

    R[delegateTo].count += R[delegateFrom].count;
    R[delegateFrom].count = 0;
    R[delegateFrom].delegateTo = delegateTo;
}

rule Vote {
	definition Vote extends Asset
}

rule Proposal {
	definition Proposal {
		name: bytes32;
		voteCount: uint;
	}

	implementation AssetDelegator<Vote, ProposalsAndVoters> for Proposal {
	    count = voteCount;
	    delegatedTo = {
	        get: {return null};
	        set: {};
	    }
	}
}

rule Voter {
	definition Voter {
		voteCount: uint;
		voteDelegatedTo: Id<ProposalsAndVoters>;
	}

    implementation AssetDelegator<Vote, ProposalsAndVoters> for Voter {
        count = voteCount;
        delegatedTo = voteDelegatedTo;
    }
}

rule Voters {
	state Voters {
		type: Map<address, Voter>;
	}
}

rule Proposals {
	state proposals {
		type: Array<Proposal>;
	}
}

rule ProposalsAndVoters {
	state proposalsAndVoters {
		type: Union<Voters, Proposals>;
	}
}

rule Chairperson {
	state chairperson {
		type: Id<Voters>;
	}
}

rule Constructor {
	function Constructor(address sender, bytes32[] proposalNames) {
		chairperson = sender;
		voters[chairperson].voteCount = 1;

		for (uint i = 0; i < proposalNames.length; i++) {
			proposals.push(Proposal({
				name: proposalNames[i],
				voteCount: 0
			}));
		}
	}

	action Constructor(bytes32[] proposalNames) {
		body = Constructor(msg.sender, proposalNames)
	}
}

rule GiveRightToVote {
	function GiveRightToVote(address voter) {
		voters[voter] = 1
	}

	action GiveRightToVote(address voter) {
		body = GiveRightToVote(address voter)
	}
}

rule DelegateToVoter {
	function DelegateToVoter(Id<Voter> sender, (Id<Voter>) to) {
		Delegate<Vote, ProposalsAndVoters>(sender, to);
	}

	action DelegateToVoter(address to) {
	    body = DelegateToVoter((Id<Voter>) msg.sender, (Id<Voter>) to);
	}
}

rule VoteForProposal {
    function VoteForProposal(Id<Voter> sender, Id<Proposal> to) {
        Proposals[to].voteCount += Voters[sender].voteCount;
        Voters[sender].voteCount = 0;
        Voters[sender].voteDelegatedTo = to;
    }
}




